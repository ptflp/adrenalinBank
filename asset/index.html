<!doctype html>
<html>
<head>
    <title>Realtime DIY AEB TRANSACTION</title>
    <style>
      body {
  background-color:black;
}
h1,p {
color: white;
}
svg {
display: block;
margin: auto;
}
    </style>
</head>
<body>
<h1>Realtime DIY AEB TRANSACTION</h1>
<p id="status">Not connected</p>
<svg width="600" height="600" id="bubbleCanvas" class="vizCanvas"></svg>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script>
          var txNodes = [];

          var svg = d3.select("#bubbleCanvas"),
              width = +svg.attr("width"),
              height = +svg.attr("height");
          var centerX = width / 2.0;
          var centerY = height / 2.0;
          var counter = 0;

          var node = svg.append("g")
              .attr("class", "nodes")
              .selectAll("circle");

        var bubbleSimulation = d3.forceSimulation(txNodes)
            .force("charge", d3.forceManyBody().strength(-3))
            .force("x", d3.forceX())
            .force("y", d3.forceY())
            .force("collision", d3.forceCollide(function radius(d,i){return d.scaledValue;}))
            .alphaTarget(1)
            .on("tick", bubblesTicked);

        		var websocket;

            function init() {
              websocket = new WebSocket("ws://" + location.host + "/echo");

              websocket.onopen = function() {
                document.getElementById("status").innerHTML ="Connected";
                };

             	websocket.onerror = function(event) {
                document.getElementById("status").innerHTML = "Error";
              };

              websocket.onmessage = function(event) {
              	//message processing code goes here
              	console.log(event);
                var msgData = JSON.parse(event.data);
                value = msgData/100;
                    console.log(msgData);
                    var i = 0;
                    var interval = setInterval(function() {
                      if (i < msgData.length) {
                      if (msgData[i].Amount <0 ) {
                        msgData[i].Amount = -msgData[i].Amount;
                       }
                          var newTx = {id:msgData[i].Id, value: msgData[i].Amount, scaledValue: 5 + Math.log(msgData[i].Amount) };
                          console.log(newTx);
                          txNodes.push(newTx);
                          if (txNodes.length > 400)
                          {
                                txNodes.shift();
                          }
                          bubblesRestart();
                        i++;
                      }
                    },1800);
                  if (msgData.Amount < 0) {
                    msgData.Amount = -msgData.Amount
                  }
              };
            };

            function sendMessage(message) {
              document.getElementById("output").innerHTML = message;
              websocket.send(message);
            }

        function bubblesRestart() {
          var updateSelection = node.data(txNodes, function(d) { return d.id;}); //updated transactions
        	updateSelection.exit().remove(); //removed transactions
          var enterSelection = updateSelection.enter()
          .append("circle")
          .attr("r", function(d){return d.scaledValue;})
          .attr("fill",function(d){return d3.hsl(180 + Math.min(d.value * 4, 180),1,0.5);}); //new transactions
          node = updateSelection.merge(enterSelection);
          bubbleSimulation.nodes(txNodes);
          bubbleSimulation.alpha(1).restart();
        }

         function bubblesTicked() {
            node.attr("cx", function(d) { return d.x + centerX; })
            .attr("cy", function(d) { return d.y + centerY; });
          }

            function start() {
            websocket.send('{"op":"unconfirmed_sub"}');
            }

            function stop() {
            	websocket.send('{"op":"unconfirmed_unsub"}');
            }

            window.addEventListener("load", init, false);
        </script>
</body>
</html>